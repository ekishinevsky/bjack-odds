<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="dark" />
  <title>Gambler’s Ruin — Eli Kishinevsky</title>
  <meta name="description" content="Bankroll vs goal with adjustable win/loss amounts and per-bet win chance. Shows ruin chance, chance to hit goal, and expected number of bets." />

  <!-- GA4 (optional) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BWPMBYVSD5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BWPMBYVSD5');
  </script>

  <style>
    :root{
      --bg:#0b0b0f; --card:#121217; --text:#f2f3f5; --muted:#a6a8ad;
      --accent:#5b8cff; --border:#22242b; --radius:14px;
      --good:#7aff9a; --bad:#ff7a7a;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.55 Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    a{color:var(--accent);text-decoration:none}
    .container{max-width:980px;margin:0 auto;padding:22px}
    .nav{position:sticky;top:0;background:linear-gradient(180deg,#0b0b0f,#0b0b0fd0);backdrop-filter:saturate(130%) blur(6px);border-bottom:1px solid var(--border);z-index:5}
    .nav-inner{display:flex;justify-content:space-between;align-items:center;gap:14px}
    .brand{display:flex;align-items:center;gap:10px;color:var(--text);font-weight:800;text-decoration:none}
    .dot{width:10px;height:10px;border-radius:999px;background:linear-gradient(135deg,var(--accent),#8ea8ff);box-shadow:0 0 14px rgba(91,140,255,.66)}
    nav a{color:var(--muted);margin-left:14px}
    nav a.active, nav a:hover{color:var(--text)}
    h1,h2,h3{margin:0 0 8px}
    .section{padding:24px 0}
    .muted{color:var(--muted)}
    .cap{font-variant:all-small-caps;letter-spacing:.5px;color:var(--muted)}
    .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);padding:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:end}
    label{display:flex;flex-direction:column;gap:6px;font-size:14px}
    .input{
      border:1px solid var(--border);background:linear-gradient(180deg,#121217,#0c0c10);
      color:var(--text);border-radius:10px;padding:8px 10px;min-width:160px
    }
    .btn{border:1px solid var(--border);background:#101015;color:var(--text);border-radius:10px;padding:8px 10px;cursor:pointer}
    .chips{display:flex;gap:10px;flex-wrap:wrap;margin:8px 0 12px}
    .chip{border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:#101015;cursor:pointer}
    .headline{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;background:var(--card);border:1px solid var(--border);border-radius:var(--radius);padding:14px}
    .box{border:1px solid var(--border);border-radius:12px;padding:12px;background:#101015}
    .big{font-size:30px;font-weight:900}
    .good{color:var(--good)} .bad{color:var(--bad)}
    .small{font-size:12px;color:var(--muted)}
    .stats{display:grid;grid-template-columns:repeat(4, minmax(140px,1fr));gap:10px}
    details{border:1px solid var(--border);border-radius:12px;padding:10px 12px;background:#0e0e14}
    details summary{cursor:pointer;color:var(--muted)}
    footer{border-top:1px solid var(--border);margin-top:24px}
    .warn{color:#ffcd7a}
  </style>
</head>
<body>
  <!-- NAV -->
  <div class="nav">
    <div class="container nav-inner">
      <a class="brand" href="index.html"><span class="dot"></span><span>Probability Tools</span></a>
      <nav>
        <a href="index.html">All Tools</a>
        <a class="active" href="gamblers-ruin.html">Gambler’s Ruin</a>
        <a href="https://ekishinevsky.github.io/" target="_blank" rel="noopener">Main Site</a>
      </nav>
    </div>
  </div>

  <section class="section">
    <div class="container">
      <h2>Gambler’s Ruin (with Risk–Reward)</h2>
      <p class="muted">Per bet you <strong>win +W</strong> with probability <strong>p</strong> and <strong>lose −L</strong> with probability <strong>1−p</strong>. We track between $0 and your goal.</p>

      <!-- Presets -->
      <div class="chips">
        <span class="chip" data-br="100" data-goal="200" data-win="10" data-loss="10" data-p="50">Even bet: $100→$200, +$10 / −$10, p=50%</span>
        <span class="chip" data-br="100" data-goal="200" data-win="20" data-loss="10" data-p="45">2:1 reward: +$20 / −$10, p=45%</span>
        <span class="chip" data-br="100" data-goal="200" data-win="10" data-loss="20" data-p="60">1:2 reward: +$10 / −$20, p=60%</span>
      </div>

      <!-- Inputs -->
      <div class="card">
        <div class="row">
          <label>Bankroll ($)
            <input id="bankroll" class="input" type="number" min="0" step="0.01" value="100" />
          </label>
          <label>Goal ($)
            <input id="goal" class="input" type="number" min="0" step="0.01" value="200" />
          </label>
          <label>Win amount per bet (+W, $)
            <input id="winAmt" class="input" type="number" min="0.01" step="0.01" value="10" />
          </label>
          <label>Loss amount per bet (−L, $)
            <input id="lossAmt" class="input" type="number" min="0.01" step="0.01" value="10" />
          </label>
          <label>Win chance per bet (p, %)
            <input id="p" class="input" type="number" min="0" max="100" step="0.1" value="50" />
          </label>
          <button class="btn" id="reset">Reset</button>
        </div>
        <div class="small" id="unitNote"></div>
        <div class="small" id="coarsenNote"></div>
      </div>

      <!-- Main results -->
      <div class="headline" style="margin-top:14px">
        <div class="box">
          <div class="cap">Probability of ruin</div>
          <div id="pruin" class="big bad">—</div>
        </div>
        <div class="box">
          <div class="cap">Probability of reaching goal</div>
          <div id="pgoal" class="big good">—</div>
        </div>
        <div class="box">
          <div class="cap">Expected number of bets (to ruin or goal)</div>
          <div id="etime" class="big">—</div>
        </div>
      </div>

      <!-- Secondary stats -->
      <div class="stats" style="margin-top:12px">
        <div class="box">
          <div class="cap">Grid steps</div>
          <div id="steps" class="big">—</div>
          <div class="small">Up step = +W, Down step = −L (mapped to integers via cents & gcd)</div>
        </div>
        <div class="box">
          <div class="cap">Per-bet $ edge</div>
          <div id="edgeMoney" class="big">—</div>
          <div class="small">p·W − (1−p)·L</div>
        </div>
        <div class="box">
          <div class="cap">Directional drift (steps)</div>
          <div id="drift" class="big">—</div>
          <div class="small">p·u − (1−p)·v (u,v are step counts)</div>
        </div>
        <div class="box">
          <div class="cap">Model assumptions</div>
          <div class="small">Independent bets; constant W/L; stop at $0 or goal.</div>
        </div>
      </div>

      <!-- Explainer -->
      <div class="section">
        <details>
          <summary>How the probabilities are computed</summary>
          <p class="muted" style="margin-top:6px">
            We convert dollars to cents and reduce by <em>gcd(W,L)</em> so each bet is an “up <strong>u</strong> steps / down <strong>v</strong> steps” random walk
            between 0 and <strong>N</strong>=ceil(goal/unit). The chance to hit the goal from step <strong>i</strong>=floor(bankroll/unit) is:
          </p>
          <ul class="muted">
            <li>If the nontrivial root <code>r≠1</code> of <code>p·r^u + (1−p)·r^{-v} = 1</code> exists, then
              <code>p_goal = (1 − r^i)/(1 − r^N)</code>, and <code>p_ruin = 1 − p_goal</code>.</li>
            <li>If effectively <code>r≈1</code> (zero drift), we use the limit <code>p_goal = i/N</code>.</li>
          </ul>
          <p class="muted">Expected #bets is solved from the linear system <code>E[i] = 1 + p·E[i+u] + (1−p)·E[i−v]</code> with <code>E[0]=E[N]=0</code>
          (computed when the state space is modest; otherwise we omit it).</p>
        </details>
      </div>
    </div>
  </section>

  <footer class="section">
    <div class="container">
      <div class="muted">© <span id="year"></span> Eli Kishinevsky</div>
    </div>
  </footer>

  <script>
    // Footer year
    document.getElementById('year').textContent = new Date().getFullYear();

    // Elements
    const brEl = document.getElementById('bankroll');
    const goalEl = document.getElementById('goal');
    const winEl = document.getElementById('winAmt');
    const lossEl = document.getElementById('lossAmt');
    const pEl = document.getElementById('p');
    const resetBtn = document.getElementById('reset');

    const unitNoteEl = document.getElementById('unitNote');
    const coarsenNoteEl = document.getElementById('coarsenNote');
    const pruinEl = document.getElementById('pruin');
    const pgoalEl = document.getElementById('pgoal');
    const etimeEl = document.getElementById('etime');
    const stepsEl = document.getElementById('steps');
    const edgeMoneyEl = document.getElementById('edgeMoney');
    const driftEl = document.getElementById('drift');

    // Presets
    document.querySelectorAll('.chip').forEach(c => c.addEventListener('click', () => {
      brEl.value = c.dataset.br;
      goalEl.value = c.dataset.goal;
      winEl.value = c.dataset.win;
      lossEl.value = c.dataset.loss;
      pEl.value = c.dataset.p;
      recompute();
    }));

    [brEl, goalEl, winEl, lossEl, pEl].forEach(el => el.addEventListener('input', recompute));
    resetBtn.addEventListener('click', () => {
      brEl.value = 100; goalEl.value = 200; winEl.value = 10; lossEl.value = 10; pEl.value = 50;
      recompute();
    });

    const pct = x => (x*100).toFixed(2)+'%';
    const money = x => '$' + Number(x).toLocaleString(undefined,{maximumFractionDigits:2});
    const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));
    const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; };

    // Root for p*r^u + q*r^{-v} = 1, the nontrivial r != 1
    function otherRoot(u,v,p){
      const q = 1 - p;
      if (p === 0) return Infinity;
      if (p === 1) return 0;

      // f(r) = p r^u + q r^{-v} - 1; f(1)=0 always. We want the root r!=1.
      const f = r => p*Math.pow(r,u) + q*Math.pow(r,-v) - 1;

      // Drift sign tells which side the root lies on.
      const drift = p*u - q*v;
      const eps = 1e-12;

      // If drift ~ 0 -> r ~ 1
      if (Math.abs(drift) < 1e-14) return 1;

      // Bisection
      let a, b;
      if (drift > 0){
        // root in (0,1)
        a = 1e-12; b = 1 - 1e-12;
        // ensure signs opposite
        // f(a) > 0 (huge), want f(b) < 0 near 1
        let fb = f(b);
        // shrink b if needed
        for(let k=0;k<60 && fb >= 0;k++){ b = 1 - (1 - b)*2; fb = f(b); }
      } else {
        // root in (1, +inf)
        a = 1 + 1e-12; b = 2;
        // ensure f(a) < 0 just above 1
        let fa = f(a);
        if (fa >= 0){
          // nudge a until negative
          for(let k=0;k<60 && fa >= 0;k++){ a = 1 + (a-1)/2; fa = f(a); }
        }
        // increase b until positive
        let fb = f(b);
        for(let k=0;k<60 && fb <= 0;k++){ b *= 2; fb = f(b); if(b>1e12) break; }
      }

      // If brackets failed, fall back to r≈1
      if (!isFinite(a) || !isFinite(b)) return 1;

      // Bisection iterations
      let lo = a, hi = b, mid = 1;
      for(let it=0; it<120; it++){
        mid = (lo + hi)/2;
        const fm = f(mid);
        if (Math.abs(fm) < 1e-14) break;
        // pick side: need to know sign at lo
        const flo = f(lo);
        if ((flo <= 0 && fm <= 0) || (flo >= 0 && fm >= 0)) lo = mid; else hi = mid;
      }
      return mid;
    }

    // Probability to hit goal using root method (exact)
    function goalProb(i,N,u,v,p){
      const q = 1 - p;
      if (i <= 0) return 0;
      if (i >= N) return 1;
      if (p <= 0) return 0;
      if (p >= 1) return 1;

      const r = otherRoot(u,v,p);
      if (!isFinite(r) || Math.abs(r - 1) < 1e-10){
        // near fair (in this step metric): linear limit
        return i / N;
      } else {
        const r_i = Math.pow(r, i);
        const r_N = Math.pow(r, N);
        return (1 - r_i) / (1 - r_N);
      }
    }

    // Expected time via Gauss-Seidel when state space is small
    function expectedTimeGS(N,u,v,p){
      const q = 1 - p;
      const E = new Float64Array(N+1);
      const MAX_IT = 200000;
      const TOL = 1e-10;
      for(let it=0; it<MAX_IT; it++){
        let maxDelta = 0;
        for(let i=1; i<=N-1; i++){
          const jp = Math.min(N, i + u);
          const jm = Math.max(0, i - v);
          const newEi = 1 + p * E[jp] + q * E[jm];
          const d = Math.abs(newEi - E[i]);
          if (d > maxDelta) maxDelta = d;
          E[i] = newEi;
        }
        if (maxDelta < TOL) break;
        if (it === MAX_IT - 1) return null; // did not converge
      }
      return E;
    }

    function recompute(){
      const bankroll = Math.max(0, Number(brEl.value)||0);
      const goal = Math.max(0, Number(goalEl.value)||0);
      const W = Math.max(0.01, Number(winEl.value)||0.01);
      const L = Math.max(0.01, Number(lossEl.value)||0.01);
      const p = clamp((Number(pEl.value)||0)/100, 0, 1);
      const q = 1 - p;

      // cents & gcd reduction
      let brC = Math.round(bankroll * 100);
      let goalC = Math.round(goal * 100);
      let wC = Math.round(W * 100);
      let lC = Math.round(L * 100);

      // guard
      if (goalC <= 0){
        pruinEl.textContent = '—'; pgoalEl.textContent='—'; etimeEl.textContent='—';
        stepsEl.textContent='—'; edgeMoneyEl.textContent='—'; driftEl.textContent='—';
        unitNoteEl.textContent = ''; coarsenNoteEl.textContent='';
        return;
      }

      // Unit (gcd of step sizes)
      const g = gcd(wC, lC);
      let unit = g; // cents per state step
      let u = Math.max(1, Math.round(wC / g));
      let v = Math.max(1, Math.round(lC / g));

      let i = Math.floor(brC / unit);
      let N = Math.ceil(goalC / unit);

      // Coarsen grid if too large
      const MAX_STATES = 6000;
      let coarsened = false;
      if (N > MAX_STATES){
        const factor = Math.ceil(N / MAX_STATES);
        unit *= factor;
        i = Math.floor(brC / unit);
        N = Math.ceil(goalC / unit);
        u = Math.max(1, Math.round(wC / unit));
        v = Math.max(1, Math.round(lC / unit));
        coarsened = true;
      }

      unitNoteEl.textContent = `Grid unit = ${ (unit/100).toFixed(2) } $, start i=${i}, goal N=${N}, up-step u=${u}, down-step v=${v}.`;
      coarsenNoteEl.innerHTML = coarsened ? `<span class="warn">Large state space — using a coarser grid for speed (probabilities are very close; expected time omitted if unstable).</span>` : '';

      // Simple edges
      if (i >= N){
        pruinEl.textContent = '0.00%';
        pgoalEl.textContent = '100.00%';
        etimeEl.textContent = '0';
        stepsEl.textContent = `i=${i}, N=${N}`;
      } else if (i <= 0){
        pruinEl.textContent = '100.00%';
        pgoalEl.textContent = '0.00%';
        etimeEl.textContent = '0';
        stepsEl.textContent = `i=${i}, N=${N}`;
      } else {
        // Probabilities via root method (exact)
        const p_goal = goalProb(i,N,u,v,p);
        const p_ruin = 1 - p_goal;
        pgoalEl.textContent = pct(p_goal);
        pruinEl.textContent = pct(p_ruin);

        // Expected time (try GS if not too big)
        let showE = true;
        if (N <= MAX_STATES){
          const E = expectedTimeGS(N,u,v,p);
          if (E){
            etimeEl.textContent = Math.round(E[i]).toLocaleString();
          } else {
            etimeEl.textContent = '—';
            showE = false;
          }
        } else {
          etimeEl.textContent = '—';
          showE = false;
        }
        stepsEl.textContent = `i=${i}, N=${N}${showE?'': ' (E omitted)'}`;
      }

      // Edges / drift display
      const edgeMoney = p*W - q*L;
      edgeMoneyEl.textContent = (edgeMoney>=0?'+':'') + money(edgeMoney);
      const driftSteps = p*u - q*v;
      driftEl.textContent = (driftSteps>=0?'+':'') + driftSteps.toFixed(4);
    }

    // Boot
    recompute();
  </script>
</body>
</html>
